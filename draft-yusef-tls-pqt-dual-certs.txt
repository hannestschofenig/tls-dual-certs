



TLS Working Group                                         R. Shekh-Yusef
Internet-Draft                                                     Ciena
Updates: RFC9261, RFC8446 (if approved)                    H. Tschofenig
Intended status: Standards Track                                   H-BRS
Expires: 20 December 2025                                   M. Ounsworth
                                                                 Entrust
                                                              Y. Sheffer
                                                                  Intuit
                                                                T. Reddy
                                                                   Nokia
                                                            Y. Rosomakho
                                                                 Zscaler
                                                            18 June 2025


    Post-Quantum Traditional (PQ/T) Hybrid Authentication with Dual
                        Certificates in TLS 1.3
                 draft-yusef-tls-pqt-dual-certs-latest

Abstract

   This document extends the TLS 1.3 authentication mechanism to allow
   the negotiation and use of two signature algorithms to enable dual-
   algorithm hybrid authentication, ensuring that an attacker would need
   to break both algorithms to compromise the session.  The two
   signature algorithms come from two independent certificates that
   together produce a single Certificate and CertificateVerify message.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the Transport Layer
   Security mailing list (tls@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/tls/.

   Source for this draft and an issue tracker can be found at
   https://github.com/hannestschofenig/tls-dual-certs.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 20 December 2025.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Scope
   4.  Design Overview
     4.1.  Signature Algorithms Negotiation
     4.2.  Certificate Chain Encoding
     4.3.  CertificateVerify Signatures
   5.  Protocol Changes
     5.1.  dual_signature_algorithms Extension
       5.1.1.  Structure
       5.1.2.  Use in Handshake and Exported Authenticator Messages
     5.2.  Certificate Message Encoding
       5.2.1.  Delimiter
     5.3.  CertificateVerify Message
       5.3.1.  Context Strings
     5.4.  Dual Certificate Policy Enforcement
   6.  Performance Considerations
   7.  Client-Driven Authentication Requirements
     7.1.  Type 1: Single-certificate
     7.2.  Type 2: Dual-Compatible, PQ Optional (Classic Primary)
     7.3.  Type 3: Strict Dual
     7.4.  Type 4: Dual-Compatible, Classic Optional (PQ Primary)
     7.5.  Compatibility with composite certificates
   8.  Security Considerations
     8.1.  Signature Association and Parsing Robustness
     8.2.  Signature Validation Requirements
     8.3.  Side-Channel Resistance
     8.4.  Cryptographic Independence
     8.5.  Certificate Usage and Trust
   9.  IANA Considerations
     9.1.  TLS extension
     9.2.  TLS alert
   10. Acknowledgments
   11. References
     11.1.  Normative References
     11.2.  Informative References
   Appendix A.  Informal Requirements for Dual TLS Certificate Support
     A.1.  Dual-Algorithm Security
       A.1.1.  Weak Non-Separability
     A.2.  Dual Certificate Semantics
       A.2.1.  Independent Chain Usability
       A.2.2.  Unambiguous Chain Separation
     A.3.  Use Case and Deployment Flexibility
       A.3.1.  Backward Compatibility
       A.3.2.  Forward Compatibility
       A.3.3.  Negotiation Expressiveness
       A.3.4.  Mitigation of Side Channels
       A.3.5.  Non-ambiguity of Message Formats
     A.4.  Interaction With Existing TLS Semantics
       A.4.1.  Protocol Flow Consistency
       A.4.2.  mTLS support
       A.4.3.  Exported Authenticators Compatibility
       A.4.4.  Minimal Protocol Changes
     A.5.  Non-Goals
       A.5.1.  Multiple Identities
   Authors' Addresses

1.  Introduction

   There are several potential mechanisms to address concerns related to
   the anticipated emergence of cryptographically relevant quantum
   computers (CRQCs).  While the encryption-related aspects are covered
   in other documents, this document focuses on the authentication
   component of the [TLS] handshake.

   One approach is the use of dual certificates: issuing two distinct
   certificates for the same end entity — one using a traditional
   algorithm (e.g., [ECDSA]), and the other using a post-quantum (PQ)
   algorithm (e.g., [ML-DSA]).

   This document defines how TLS 1.3 can utilize such certificates to
   enable dual-algorithm authentication, ensuring that an attacker would
   need to break both algorithms to compromise the session.

   It also addresses the challenges of integrating hybrid authentication
   in TLS 1.3 while balancing backward compatibility, forward security,
   and deployment practicality.

   This document defines a new extension dual_signature_algorithms to
   negotiate support for two categories of signature algorithms,
   typically one set of classic schemes and one set of PQ schemes.  It
   also makes changes to the Certificate and CertificateVerify messages
   to take advantage of both certificates when authenticating the end
   entity.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Scope

   The approach described herein is also compatible with FIPS-compliant
   deployments, as it supports the continued use of FIPS-approved
   traditional signature algorithms during the TLS handshake.

   The proposed mechanism is fully backward compatible: traditional
   certificates and authentication methods remain functional with
   existing TLS 1.3 implementations.  As cryptographically relevant
   quantum computers (CRQCs) emerge, deployments can transition by
   gradually disabling traditional authentication and enabling post-
   quantum–only authentication.  This strategy offers a smooth migration
   path, ensuring long-term cryptographic agility, regulatory
   compliance, and operational continuity without disrupting existing
   infrastructure.

4.  Design Overview

   This document introduces a mechanism to enable dual-certificate
   authentication in TLS 1.3.  The primary objective is to allow each
   TLS peer to present two certificate chains requiring an attacker to
   break both authentication algorithms to impersonate a peer.
   Typically one of the certificate chains is using a traditional
   cryptographic algorithms while the second leverages post-quantum (PQ)
   cryptography.

   The design builds on existing TLS 1.3 structures and introduces
   minimal protocol changes.  It is applicable to both client and server
   authentication and is compatible with the Exported Authenticators
   mechanism [EXPORTED-AUTH].

   A full set of informal design requirements for this specification can
   be found in Appendix A.

4.1.  Signature Algorithms Negotiation

   A new extension, dual_signature_algorithms, is defined to negotiate
   support for two distinct categories of signature algorithms.  The
   extension carries two disjoint lists: one for classical signature
   algorithms and one for post-quantum signature algorithms.

   *  In the ClientHello, this extension indicates the client's
      supported classical and PQ signature algorithms for dual
      certificate server authentication.

   *  In the CertificateRequest, this extension indicates the server's
      supported classical and PQ signature algorithms for dual
      certificate client authentication.

   This allows both endpoints to signal independently two distinct
   algorithms for dual authentication.

   The dual_signature_algorithms can also be used in extensions of
   CertificateRequest and ClientCertificateRequest structures of
   Authenticator Request message of Exported Authenticators as defined
   in Section 4 of [EXPORTED-AUTH].

   The dual_signature_algorithms extension does not replace
   signature_algorithms.  TLS peers MUST include the
   signature_algorithms extension regardless of whether
   dual_signature_algorithms is used.  The signature_algorithms
   extension indicates algorithms acceptable for single-certificate
   authentication and MUST contain either a non-empty list of such
   algorithms or be empty if only dual-certificate authentication is
   acceptable.

4.2.  Certificate Chain Encoding

   TLS 1.3 defines the Certificate message to carry a list of
   certificate entries representing a single chain.  This document
   reuses the same structure to convey two certificate chains by
   concatenating them and inserting a delimiter in the form of a zero-
   length certificate entry.

   A zero-length certificate is defined as a CertificateEntry with an
   empty cert_data field and omitted extensions field.  TLS 1.3
   prohibits the use of empty certificate entries, making this delimiter
   unambiguous.  Implementations MUST treat all entries before the zero-
   length delimiter as the first certificate chain (typically classic),
   and all entries after it as the second certificate chain (typically
   post-quantum).

   This encoding applies equally to the CompressedCertificate message
   defined in [COMPRESS-CERT] and to the Certificate message of Exported
   Authenticators as defined in Section 5.2.1 of [EXPORTED-AUTH].

   Since TLS 1.3 supports only a single certificate type in each
   direction, both certificate chains MUST either contain X.509
   certificates or certificates of type specified in:

   *  server_certificate_type extension in a EncryptedExtensions message
      for Server certificates

   *  client_certificate_type extension in a EncryptedExtensions message
      for Client certificates

   Note that according to Section 5.2.1 of [EXPORTED-AUTH] Exported
   Authenticators support only X.509 certificates.

4.3.  CertificateVerify Signatures

   The CertificateVerify message is extended to include two digital
   signatures:

   1.  One computed using a signature algorithm selected from the first
       list of the dual_signature_algorithms extension.

   2.  One computed using a signature algorithm selected from the second
       list of the dual_signature_algorithms extension.

   Each signature is computed over the transcript hash as specified in
   TLS 1.3, but with distinct context strings to domain-separate the two
   operations.

   This encoding applies equally to the CertificateVerify message of
   Exported Authenticators as defined in Section 5.2.2 of
   [EXPORTED-AUTH].

   The order of the signatures in the message MUST correspond to the
   order of the certificate chains in the Certificate message: the first
   signature MUST correspond to a classical algorithm from
   first_signature_algorithms list of dual_signature_algorithms
   extension, while the second signature MUST correspond to a PQ
   algorithm from second_signature_algorithms list of
   dual_signature_algorithms extension.

5.  Protocol Changes

   This section defines the normative changes to TLS 1.3 required to
   support dual-certificate authentication.  These changes extend
   existing handshake messages and introduce the new extension.

5.1.  dual_signature_algorithms Extension

   A new extension, dual_signature_algorithms, is defined to allow peers
   to advertise support for two distinct categories of signature
   algorithms, for example, classical and post-quantum.

5.1.1.  Structure

   The structure of the extension as follows:

   struct {
       SignatureScheme first_signature_algorithms<2..2^16-2>;
       SignatureScheme second_signature_algorithms<2..2^16-2>;
   } DualSignatureSchemeList;

         Figure 1: Contents of dual_signature_algorithms extension

   SignatureScheme is a 2-octet value identifying a supported signature
   algorithm as defined in TLS SignatureScheme IANA registry.
   first_signature_algorithms and second_signature_algorithms list MUST
   NOT contain common elements.  TLS endpoint observing such overlap
   between primary and secondary supported signature lists MUST
   terminate the connection with illegal_parameter alert.

5.1.2.  Use in Handshake and Exported Authenticator Messages

   The client MAY include this extension in ClientHello message to
   indicate the different categories of algorithms it supports for
   verifying the server's signature.  The server MAY include this
   extension in CertificateRequest message to indicate the different
   categories of algorithms it supports for verifying the client's
   signature.  This extension MAY be included in an Authenticator
   Request by the requestor to signal support for dual certificates in
   the response.

   If the extension is present in ClientHello, CertificateRequest or
   Authenticator Request, the peer MAY respond with a dual-certificate
   authentication structure.  If the extension is absent, the peer MUST
   NOT send a two certificate chains or two signatures.

   The presence of this extension alone does not mandate dual
   authentication.  It is up to the peer to determine whether one or two
   certificate chains and signatures are required based on local policy
   and validation logic.  A single certificate and a single signature
   encoded in Certificate and CertificateVerify messages remain valid as
   long as the certificate and its corresponding signature algorithm
   comply with the values in the signature_algorithms or
   signature_algorithms_cert extension.

5.2.  Certificate Message Encoding

   TLS 1.3 defines the Certificate message as follows:

   struct {
       opaque certificate_request_context<0..2^8-1>;
       CertificateEntry certificate_list<0..2^24-1>;
   } Certificate;

                   Figure 2: TLS 1.3 Certificate message

   This document extends the semantics of certificate_list to support
   two logically distinct certificate chains, encoded sequentially and
   separated by a delimiter.

5.2.1.  Delimiter

   The delimiter is a zero-length certificate entry encoded as 3 bytes
   of 0x00.  TLS 1.3 prohibits empty certificate entries, so this
   delimiter is unambiguous.  The delimiter MUST NOT be sent to peers
   that did not indicated support for dual certificates by including
   dual_signature_algorithms extension.

   This specification expands CertificateEntry structure from
   Section 4.4.2 of [TLS] in the following way:

   struct {
       select (is_delimiter) {
           case Delimiter: uint24 delimiter = 0;
           case Non_Delimiter:
             select (certificate_type) {
                 case RawPublicKey:
                   /* From RFC 7250 ASN.1_subjectPublicKeyInfo */
                   opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;

                 case X509:
                   opaque cert_data<1..2^24-1>;
             };
             Extension extensions<0..2^16-1>;
       };
   } CertificateEntry;

          Figure 3: Updated CertificateEntry structure definition

   All entries before the delimiter are treated as the first certificate
   chain and MUST use algorithms from first_signature_algorithms list of
   dual_signature_algorithms extension (for example classical
   algorithms), all entries after the delimiter are treated as the
   second certificate chain and MUST use algorithms from
   second_signature_algorithms list of dual_signature_algorithms
   extension (for example PQC algorithms).  As specified in
   Section 4.4.2 of [TLS], end-entity certificate MUST be the first in
   both chains.

   A peer receiving this structure MUST validate each chain
   independently according to its corresponding signature algorithm.
   The end-entity certificate MUST be the first entry in both the first
   and second certificate chains.  The first certificate chain MUST
   contain certificates whose public key is compatible with one of the
   algorithms listed in the first_signature_algorithms section of
   dual_signature_algorithms extension.  The second certificate chain
   MUST contain certificates whose public key is compatible with one of
   the algorithms listed in the second_signature_algorithms section of
   dual_signature_algorithms extension.

   This encoding applies equally to the CompressedCertificate message
   and to Certificate message of Exported Authenticators.

5.3.  CertificateVerify Message

   The CertificateVerify message is extended to carry two independent
   signatures.  Its modified structure is as follows:

   struct {
       SignatureScheme first_algorithm;
       opaque first_signature<0..2^16-1>;
       SignatureScheme second_algorithm;
       opaque second_signature<0..2^16-1>;
   } CertificateVerify;

                    Figure 4: CertificateVerify message

   Each signature covers the transcript hash as in TLS 1.3, but with a
   distinct context string for domain separation.

5.3.1.  Context Strings

   The context string is used as input to the data over which the
   signature is computed, consistent with the CertificateVerify
   construction defined in Section 4.4.3 of [TLS].  The first signature
   uses the same context string as in the TLS 1.3 specification:

   *  for a server context string is "TLS 1.3, server CertificateVerify"

   *  for a client context string is "TLS 1.3, client CertificateVerify"

   The second signature uses a distinct context string to bind it to the
   secondary certificate:

   *  for a server, secondary context string is "TLS 1.3, server
      secondary CertificateVerify"

   *  for a client, secondary context string is "TLS 1.3, client
      secondary CertificateVerify"

   Implementations MUST verify both signatures and MUST associate each
   with its corresponding certificate chain.

   This dual-signature structure applies equally to CertificateVerify
   messages carried in Exported Authenticators with second signature
   using "Secondary Exported Authenticator" as the context string.

5.4.  Dual Certificate Policy Enforcement

   Policy enforcement regarding the use of dual certificates is
   implementation-defined and driven by the authenticating peer.  When
   dual certificate authentication is required by local policy, such as
   during high-assurance sessions or post-quantum transition periods,
   the authenticating endpoint MUST abort a handshake where only one
   signature or one certificate chain is present with an
   dual_certificate_required alert.  Implementations MUST ensure that
   both certificates and both signatures are processed together and MUST
   NOT accept fallback to single-certificate authentication when dual-
   authentication is expected.

   A single composite certificate chain and signature such as defined by
   [TLS-COMPOSITE-MLDSA] MAY be an acceptable alternative during post-
   quantum transition period as long as corresponding signature scheme
   is listed in signature_algorithms extension.

6.  Performance Considerations

   The use of dual certificates increases the size of individual
   certificates, certificate chains, and associated signatures, which
   can result in significantly larger TLS handshake messages.  These
   larger payloads may cause packet fragmentation, retransmissions, and
   handshake delays, especially in constrained or lossy network
   environments.

   To mitigate these impacts, deployments can apply certificate chain
   optimization techniques, such as those described in Section 6.1 of
   [PQ-RECOMMEND], to minimize transmission overhead and improve
   handshake robustness.

7.  Client-Driven Authentication Requirements

   The scenarios in this section describe server authentication behavior
   based on client policy.  Each case reflects a different client
   capability and authentication policy, based on how the client
   populates the signature_algorithms, signature_algorithms_cert, and
   dual_signature_algorithms extensions.

   For client authentication, the same principles apply with roles
   reversed: the server drives authentication requirements by sending a
   CertificateRequest message that includes appropriate extensions.

7.1.  Type 1: Single-certificate

   Client requires only one classical, pq or a composite signature.
   Client does not support dual certificates.

   Client behavior:

   *  Includes supported algorithms in signature_algorithms and
      optionally signature_algorithms_cert.

   *  Does not include dual_signature_algorithms.

   To satisfy this client, the server MUST send a single certificate
   chain with compatible algorithms and include a single signature in
   CertificateVerify.

7.2.  Type 2: Dual-Compatible, PQ Optional (Classic Primary)

   Client supports both classical and PQ authentication.  It allows the
   server to send either a classical chain alone or both chains.

   Client behavior:

   *  Includes supported classical algorithms in signature_algorithms
      and optionally signature_algorithms_cert.

   *  Includes supported classical algorithms in
      first_signature_algorithms list of dual_signature_algorithms and
      supported PQ algorithms in second_signature_algorithms list of
      dual_signature_algorithms.

   To satisfy this client, the server MUST either:

   *  Provide a single certificate chain with compatible classical
      algorithms and include a single signature in CertificateVerify

   *  Provide a classical certificate chain followed by a PQ certificate
      chain as described in Section 5.2 and two signatures in
      CertificateVerify as described in Section 5.3

7.3.  Type 3: Strict Dual

   Client requires both classical and PQ authentication to be performed
   simultaneously.  It does not support composite certificates.

   Client behavior:

   *  Includes an empty list in signature_algorithms.

   *  Includes supported classical algorithms in
      first_signature_algorithms list of dual_signature_algorithms and
      supported PQ algorithms in second_signature_algorithms list of
      dual_signature_algorithms.

   To satisfy this client, the server MUST provide a classical
   certificate chain followed by a PQ certificate chain as described in
   Section 5.2 and two signatures in CertificateVerify as described in
   Section 5.3

7.4.  Type 4: Dual-Compatible, Classic Optional (PQ Primary)

   Client supports both classical and PQ authentication.  It allows the
   server to send either a PQ chain alone or both chains.

   Client behavior:

   *  Includes supported PQ algorithms in signature_algorithms and
      optionally signature_algorithms_cert.

   *  Includes supported classical algorithms in
      first_signature_algorithms list of dual_signature_algorithms and
      supported PQ algorithms in second_signature_algorithms list of
      dual_signature_algorithms.

   To satisfy this client, the server MUST either:

   *  Provide a single certificate chain with compatible PQ algorithms
      and include a single signature in CertificateVerify

   *  Provide a PQ certificate chain followed by a classical certificate
      chain as described in Section 5.2 and two signatures in
      CertificateVerify as described in Section 5.3

7.5.  Compatibility with composite certificates

   Clients and servers may choose to support composite certificate
   schemes, such as those defined in [TLS-COMPOSITE-MLDSA].  In these
   schemes, a single certificate contains a composite public keys, and
   the associated signature proves knowledge of private keys of all
   components.

   If a composite signature algorithm appears in the
   signature_algorithms extension, it can fulfill the client's
   requirements for both classical and PQ authentication in a single
   certificate and signature.  It is up to the client policy to decide
   whether a composite certificate is acceptable in place of a dual-
   certificate configuration.  This allows further deployment
   flexibility and compatibility with hybrid authentication strategies.

8.  Security Considerations

8.1.  Signature Association and Parsing Robustness

   Implementations MUST strictly associate each CertificateVerify
   signature with the corresponding certificate chain, based on their
   order relative to the zero-length delimiter in the Certificate
   message.  Failure to properly align signatures with their intended
   certificate chains may result in incorrect validation or
   misattribution of authentication.

   Certificate parsing logic MUST reject messages that contain more than
   one zero-length delimiter, or that place the delimiter as the first
   or last entry in the certificate list.

8.2.  Signature Validation Requirements

   Both signatures in the CertificateVerify message MUST be validated
   successfully and correspond to their respective certificate chains.
   Implementations MUST treat failure to validate either signature as a
   failure of the authentication process.  Silent fallback to single-
   certificate verification undermines the dual-authentication model and
   introduces downgrade risks.

8.3.  Side-Channel Resistance

   Since both CertificateVerify operations involve signing the
   transcript using different cryptographic primitives, care MUST be
   taken to avoid leaking side-channel information.  Implementers MUST
   ensure constant-time execution and avoid conditional branching that
   could reveal whether one or both signatures are present or valid.

   Distinct context strings are REQUIRED for the two signatures to
   prevent cross-protocol misuse or collision attacks.

8.4.  Cryptographic Independence

   To achieve the intended security guarantees, implementers and
   deployment operators MUST ensure that the two certificate chains rely
   on cryptographically independent primitives.

8.5.  Certificate Usage and Trust

   Certificate chains must be validated independently, including trust
   anchors, certificate usage constraints, expiration, and revocation
   status.  Operators MUST ensure that revocation checking, such as
   using OCSP or CRLs, is consistently applied to both chains to prevent
   reliance on revoked credentials.

9.  IANA Considerations

   This specification registers the dual_signature_algorithms TLS
   extension and dual_certificate_required TLS alert.

9.1.  TLS extension

   IANA is requested to assign a new value from the TLS ExtensionType
   Values registry:

   *  Extension Name: dual_signature_algorithms

   *  TLS 1.3: CH, CR

   *  DTLS-Only: N

   *  Recommended: Y

   *  Reference: [[This document]]

9.2.  TLS alert

   IANA is requested to add the following entry to the "TLS Alerts"
   registry:

   *  Value: TBD

   *  Description: dual_certificate_required

   *  DTLS-OK: Y

   *  Reference: [[This document]]

   *  Comment: None

10.  Acknowledgments

   We would like to thank Suzanne Wibada (Université de Sherbrooke) for
   her reviews and comments during the work on the initial version of
   this document, and her willingness to implement the recommendation of
   this document.

11.  References

11.1.  Normative References

   [EXPORTED-AUTH]
              Sullivan, N., "Exported Authenticators in TLS", RFC 9261,
              DOI 10.17487/RFC9261, July 2022,
              <https://www.rfc-editor.org/rfc/rfc9261>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [TLS]      Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", Work in Progress, Internet-Draft, draft-
              ietf-tls-rfc8446bis-12, 17 February 2025,
              <https://datatracker.ietf.org/doc/html/draft-ietf-tls-
              rfc8446bis-12>.

11.2.  Informative References

   [COMPRESS-CERT]
              Ghedini, A. and V. Vasiliev, "TLS Certificate
              Compression", RFC 8879, DOI 10.17487/RFC8879, December
              2020, <https://www.rfc-editor.org/rfc/rfc8879>.

   [ECDSA]    "Digital Signature Standard (DSS)", National Institute of
              Standards and Technology (U.S.),
              DOI 10.6028/nist.fips.186-5, February 2023,
              <https://doi.org/10.6028/nist.fips.186-5>.

   [ML-DSA]   Hollebeek, T., Schmieg, S., and B. Westerbaan, "Use of ML-
              DSA in TLS 1.3", Work in Progress, Internet-Draft, draft-
              ietf-tls-mldsa-00, 16 May 2025,
              <https://datatracker.ietf.org/doc/html/draft-ietf-tls-
              mldsa-00>.

   [PQ-RECOMMEND]
              Reddy.K, T. and H. Tschofenig, "Post-Quantum Cryptography
              Recommendations for TLS-based Applications", Work in
              Progress, Internet-Draft, draft-reddy-uta-pqc-app-07, 25
              February 2025, <https://datatracker.ietf.org/doc/html/
              draft-reddy-uta-pqc-app-07>.

   [Signature-Spectrums]
              Bindel, N., Hale, B., Connolly, D., and F. D, "Hybrid
              signature spectrums", Work in Progress, Internet-Draft,
              draft-ietf-pquip-hybrid-signature-spectrums-06, 9 January
              2025, <https://datatracker.ietf.org/doc/html/draft-ietf-
              pquip-hybrid-signature-spectrums-06>.

   [TLS-COMPOSITE-MLDSA]
              Reddy.K, T., Hollebeek, T., Gray, J., and S. Fluhrer, "Use
              of Composite ML-DSA in TLS 1.3", Work in Progress,
              Internet-Draft, draft-tls-reddy-composite-mldsa-00, 2
              November 2024, <https://datatracker.ietf.org/doc/html/
              draft-tls-reddy-composite-mldsa-00>.

Appendix A.  Informal Requirements for Dual TLS Certificate Support

   This section documents the design requirements that drove the
   development of this specification.

   This section is primarily intended to easy WG review and could be
   removed or simplified prior to RFC publication.

A.1.  Dual-Algorithm Security

A.1.1.  Weak Non-Separability

   The dual certificate authentication achieves, at least, Weak Non-
   Separability [Signature-Spectrums] at the time of verification of the
   CertificateVerify message.

A.2.  Dual Certificate Semantics

A.2.1.  Independent Chain Usability

   Each certificate chain (e.g., classic and PQ) must be independently
   usable for authentication, allowing endpoints to fall back to classic
   or PQ-only validation if necessary.

A.2.2.  Unambiguous Chain Separation

   The mechanism must clearly distinguish and delimit multiple
   certificate chains to prevent ambiguity or misinterpretation.

A.3.  Use Case and Deployment Flexibility

A.3.1.  Backward Compatibility

   When only one certificate chain is used, the mechanism must remain
   compatible with existing TLS 1.3 endpoints unaware of dual-
   certificate support or willing to use only a single certificate.

A.3.2.  Forward Compatibility

   The mechanism must be capable of negotiating algorithms requiring
   dual certificates as well as algorithms that are acceptable
   standalone.

   As an example, the mechanism must be capable of expressing the
   following algorithm preference:

      I would accept SLH-DSA-128s, Composite_MLDSA65_RSA2048
      Composite_MLDSA65_ECDSA-P256, or ML-DSA-87 by themselves, or a
      dual-cert hybrid with one of [ML-DSA-44, ML-DSA-65] with one of
      [RSA, ECDSA-P256, ECDSA-P384].

A.3.3.  Negotiation Expressiveness

   Signature algorithm negotiation, whether single or dual, must arrive
   at a unique selection of algorithms if and only if there is at least
   one configuration that is mutually-acceptable to client and server.
   Specifically, the negotiation mechanism must be expressive enough
   that clients can list all valid configurations that they would
   accept.  Conversely, the negotiation mechanism must be specific
   enough that the client is not forced, through clumsiness of the
   negotiation mechanism to list configurations that in fact it does not
   support and thus rely on failures and retries to arrive at an
   acceptable algorithm selection.

A.3.4.  Mitigation of Side Channels

   The mechanism should avoid constructions that enable side-channel
   attacks by observing how distinct algorithms are applied to the same
   message.

   _MikeO: I have never seen this particular side-channel attack
   described in the literature, so I think a reference is needed.  Also,
   side-channels is a very wide field, so it seems odd to pick out only
   a very specific type of side-channels to mention.  I suggest removing
   this section._

A.3.5.  Non-ambiguity of Message Formats

   The order and pairing between certificates and their corresponding
   signatures must be explicit, so verifiers can unambiguously match
   them.

A.4.  Interaction With Existing TLS Semantics

A.4.1.  Protocol Flow Consistency

   Dual certificate authentication must follow the same logical flow as
   standard TLS certificate authentication, including integration with
   Certificate, CertificateVerify, and Finished messages.

A.4.2.  mTLS support

   The mechanism must support both server and client authentication
   scenarios.  In case of mutual authentication dual certificates may be
   used unidirectionally as well as bidirectionally.

A.4.3.  Exported Authenticators Compatibility

   The mechanism must be usable with Exported Authenticators (RFC 9261)
   for mutual authentication in post-handshake settings.

A.4.4.  Minimal Protocol Changes

   Any additions or modifications to the TLS protocol must be minimal to
   ease deployment, reduce implementation complexity and minimize new
   security risks.

   This requirement favours a design which minimizes interaction with
   other TLS extensions -- ie where all other extensions related to
   certificates will transfer their semantics from a single-certificate
   to a dual-certificate setting in a trivial and obvious way and no
   special processing rules need to be described.  Ditto for existing
   IANA registries relating to the TLS protocol.

A.5.  Non-Goals

   The following are listed as non-goals; i.e. they are out-of-scope and
   will not be considered in the design of dual certificate
   authentication.

A.5.1.  Multiple Identities

   This mechanism is specific to cryptographic algorithm migration.  It
   is not a generic mechanism for using multiple identities in a single
   TLS handshake.  In particular, this mechanism does not allow for
   negotiating two certificates with the same algorithm but containing
   different identifiers, or for negotiating two independent sets of
   certificate_authorities.

Authors' Addresses

   Rifaat Shekh-Yusef
   Ciena
   Canada
   Email: rifaat.s.ietf@gmail.com


   Hannes Tschofenig
   University of Applied Sciences Bonn-Rhein-Sieg
   Germany
   Email: hannes.tschofenig@gmx.net


   Mike Ounsworth
   Entrust
   Canada
   Email: mike.ounsworth@entrust.com


   Yaron Sheffer
   Intuit
   Israel
   Email: yaronf.ietf@gmail.com


   Tirumaleswar Reddy
   Nokia
   India
   Email: kondtir@gmail.com


   Yaroslav Rosomakho
   Zscaler
   Email: yrosomakho@zscaler.com
